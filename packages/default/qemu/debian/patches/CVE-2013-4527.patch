Backport of the following commit.
Also includes 5bf81c8d63db0216a4d29dc87f9ce530bb791dd1
and 4082f0889ba04678fc14816c53e1b9251ea9207e to gain VMSTATE_VALIDATE

From 3f1c49e2136fa08ab1ef3183fd55def308829584 Mon Sep 17 00:00:00 2001
From: Michael S. Tsirkin <mst@redhat.com>
Date: Thu, 3 Apr 2014 19:51:23 +0300
Subject: [PATCH] hpet: fix buffer overrun on invalid state load

CVE-2013-4527 hw/timer/hpet.c buffer overrun

hpet is a VARRAY with a uint8 size but static array of 32

To fix, make sure num_timers is valid using VMSTATE_VALID hook.

Reported-by: Anthony Liguori <anthony@codemonkey.ws>
Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
Reviewed-by: Dr. David Alan Gilbert <dgilbert@redhat.com>
Signed-off-by: Juan Quintela <quintela@redhat.com>
---
 hw/timer/hpet.c |   13 +++++++++++++
 1 files changed, 13 insertions(+), 0 deletions(-)

Index: qemu-2.0.0+dfsg/hw/timer/hpet.c
===================================================================
--- qemu-2.0.0+dfsg.orig/hw/timer/hpet.c	2014-08-12 09:20:40.882553414 -0400
+++ qemu-2.0.0+dfsg/hw/timer/hpet.c	2014-08-12 09:20:40.878553414 -0400
@@ -239,6 +239,18 @@
     return 0;
 }
 
+static bool hpet_validate_num_timers(void *opaque, int version_id)
+{
+    HPETState *s = opaque;
+
+    if (s->num_timers < HPET_MIN_TIMERS) {
+        return false;
+    } else if (s->num_timers > HPET_MAX_TIMERS) {
+        return false;
+    }
+    return true;
+}
+
 static int hpet_post_load(void *opaque, int version_id)
 {
     HPETState *s = opaque;
@@ -307,6 +319,7 @@
         VMSTATE_UINT64(isr, HPETState),
         VMSTATE_UINT64(hpet_counter, HPETState),
         VMSTATE_UINT8_V(num_timers, HPETState, 2),
+        VMSTATE_VALIDATE("num_timers in range", hpet_validate_num_timers),
         VMSTATE_STRUCT_VARRAY_UINT8(timer, HPETState, num_timers, 0,
                                     vmstate_hpet_timer, HPETTimer),
         VMSTATE_END_OF_LIST()
Index: qemu-2.0.0+dfsg/include/migration/vmstate.h
===================================================================
--- qemu-2.0.0+dfsg.orig/include/migration/vmstate.h	2014-08-12 09:20:40.882553414 -0400
+++ qemu-2.0.0+dfsg/include/migration/vmstate.h	2014-08-12 09:20:55.606553653 -0400
@@ -100,6 +100,7 @@
     VMS_MULTIPLY         = 0x200,  /* multiply "size" field by field_size */
     VMS_VARRAY_UINT8     = 0x400,  /* Array with size in uint8_t field*/
     VMS_VARRAY_UINT32    = 0x800,  /* Array with size in uint32_t field*/
+    VMS_MUST_EXIST       = 0x1000, /* Field must exist in input */
 };
 
 typedef struct {
@@ -203,6 +204,14 @@
     .offset       = vmstate_offset_value(_state, _field, _type),     \
 }
 
+/* Validate state using a boolean predicate. */
+#define VMSTATE_VALIDATE(_name, _test) { \
+    .name         = (_name),                                         \
+    .field_exists = (_test),                                         \
+    .flags        = VMS_ARRAY | VMS_MUST_EXIST,                      \
+    .num          = 0, /* 0 elements: no data, only run _test */     \
+}
+
 #define VMSTATE_POINTER(_field, _state, _version, _info, _type) {    \
     .name       = (stringify(_field)),                               \
     .version_id = (_version),                                        \
Index: qemu-2.0.0+dfsg/vmstate.c
===================================================================
--- qemu-2.0.0+dfsg.orig/vmstate.c	2014-08-12 09:20:14.000000000 -0400
+++ qemu-2.0.0+dfsg/vmstate.c	2014-08-12 09:20:55.610553653 -0400
@@ -78,6 +78,10 @@
                     return ret;
                 }
             }
+        } else if (field->flags & VMS_MUST_EXIST) {
+            fprintf(stderr, "Input validation failed: %s/%s\n",
+                    vmsd->name, field->name);
+            return -1;
         }
         field++;
     }
@@ -138,6 +142,12 @@
                     field->info->put(f, addr, size);
                 }
             }
+        } else {
+            if (field->flags & VMS_MUST_EXIST) {
+                fprintf(stderr, "Output state validation failed: %s/%s\n",
+                        vmsd->name, field->name);
+                assert(!(field->flags & VMS_MUST_EXIST));
+            }
         }
         field++;
     }
